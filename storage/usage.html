<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Usage &mdash; Encore Documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/enthought.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    <link rel="stylesheet" href="../_static/enthought.css" type="text/css" >
    <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" >
    <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" >
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        LINK_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/clipboard.min.js"></script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <script type="text/javascript" src="../_static/js/wrap_on_dot.js"></script>
    <link rel="shortcut icon" href="../_static/img/favicon.png">
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="Encore Documentation" href="../index.html" >
    <link rel="up" title="Storage" href="index.html" >
    <link rel="next" title="Key-Value Store API" href="abstract_store.html" >
    <link rel="prev" title="Key-Value Store Concepts" href="concepts.html" > 
  </head>
  <body>
  <div class="container">
    <div class="header">
    </div>
  </div>

    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../index.html">Encore Documentation</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">Storage</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="abstract_store.html" title="Key-Value Store API"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="concepts.html" title="Key-Value Store Concepts"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body" role="main">
            
  <section id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Permalink to this heading">¶</a></h1>
<p>The key-value store API gives a common API that can be used with a variety of
different backends to provide a consistent interface for storage.  If used
correctly you can swap out the backend used with little or no modification of
the user code.</p>
<section id="creating-and-connecting">
<h2>Creating and Connecting<a class="headerlink" href="#creating-and-connecting" title="Permalink to this heading">¶</a></h2>
<p>Before you use a store, you need to create an instance of the appropriate type,
and then connect to it, possibly authenticating if that is required.  For
example, the following connects to a read-only remote store via HTTP, using
HTTP Authentication:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">encore.events.api</span> <span class="kn">import</span> <span class="n">EventManager</span>
<span class="kn">from</span> <span class="nn">encore.storage.static_url_store</span> <span class="kn">import</span> <span class="n">StaticURLStore</span>

<span class="n">event_manager</span> <span class="o">=</span> <span class="n">EventManager</span><span class="p">()</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">StaticURLStore</span><span class="p">(</span><span class="n">event_manager</span><span class="p">,</span> <span class="s1">&#39;http://localhost:8080/&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;index.json&#39;</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">credentials</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;username&#39;</span><span class="p">:</span> <span class="s1">&#39;alibaba&#39;</span><span class="p">,</span> <span class="n">password</span><span class="p">:</span> <span class="s1">&#39;Open Sesame&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>At this point the store is ready to use.  You can check to see whether the store
has connected using the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.is_connected" title="encore.storage.abstract_store.AbstractReadOnlyStore.is_connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_connected()</span></code></a> method.  When you are finished
with a store, you should call its <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.disconnect" title="encore.storage.abstract_store.AbstractReadOnlyStore.disconnect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnect()</span></code></a> method to allow it to
cleanly release any resources it may be using, such as database connections.</p>
</section>
<section id="reading">
<h2>Reading<a class="headerlink" href="#reading" title="Permalink to this heading">¶</a></h2>
<p>To read from a store, you use one of the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get" title="encore.storage.abstract_store.AbstractReadOnlyStore.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>
methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;my_document&#39;</span><span class="p">)</span>
<span class="n">datastream</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">data</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">metadata</span>
</pre></div>
</div>
<p>In this case datastream is a file-like object that streams bytes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">datastream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>More likely you will have used some sort of serialization format like XML, JSON
or YAML to store your data in the document, so instead you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datastream</span><span class="p">)</span>
</pre></div>
</div>
<p>If the data is raw bytes to store into a numpy array, you can do something like
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">datastream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span>
<span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="n">dtype</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">arr</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> method supports buffered reads if your data is
larger than would comfortably fit into memory.</p>
<p>If you need to support random-access streaming, the value API also supports
a <code class="xref py py-meth docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">end)()</span></code> method that return the requested
bytes as a readable stream.</p>
<p>The metadata stores auxilliary information about the data that is stored in the
key.  It is a dictionary of reasonably serializable values (frequently it will
serialize to JSON or similar format):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Document title:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Document author:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;author&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Document encoding:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;encoding&#39;</span><span class="p">])</span>

<span class="c1"># checksum</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="k">assert</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">(</span><span class="n">document</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span> <span class="o">==</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sha1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>What metadata is stored is completely dependent on the use-case for the key-value
store: the key-value store makes no assumptions.</p>
<p>If you try to read a key which doe not exist, then the store will raise a KeyError.
If you want to see whether or not a particular key is populated, you can use the
<a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.exists" title="encore.storage.abstract_store.AbstractReadOnlyStore.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exists()</span></code></a> method.</p>
<p>Frequently you will only be interested in the data or the metadata, not both.
For these cases there are methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get_data" title="encore.storage.abstract_store.AbstractReadOnlyStore.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_data()</span></code></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get_metadata" title="encore.storage.abstract_store.AbstractReadOnlyStore.get_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_metadata()</span></code></a>
which return the appropriate entities.  For metadata, if you are only interested
in the values of some of the dictionary keys, you can supply an additional argument
<code class="docutils literal notranslate"><span class="pre">select</span></code> which will restrict the returned keys to this subset of all the keys:</p>
<blockquote>
<div><p>author_info = store.get_metadata(‘document’, select=[‘author’, ‘organization’])</p>
</div></blockquote>
<p>It is very common that you either want to extract the stream of bytes from a value
into a Python bytes object (ie. a string in Python 2, as opposed to unicode) or
into a file on the local filesystem.  Two utility methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.to_file" title="encore.storage.abstract_store.AbstractReadOnlyStore.to_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_file()</span></code></a>
and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.to_bytes" title="encore.storage.abstract_store.AbstractReadOnlyStore.to_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_bytes()</span></code></a> are provided which perform these operations.  If the
data source is larger than will comfortably fit into memory (particularly for
<a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.to_file" title="encore.storage.abstract_store.AbstractReadOnlyStore.to_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_file()</span></code></a>) you can supply an optional buffer size:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">store</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;document&#39;</span><span class="p">,</span> <span class="s1">&#39;local_document.txt&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">8096</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="querying">
<h2>Querying<a class="headerlink" href="#querying" title="Permalink to this heading">¶</a></h2>
<p>Frequently you want to find keys whose metadata match certain criteria.  The
key-value store API gives a simple query mechanism that permits this sort of
matching:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">metadata</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">author</span><span class="o">=</span><span class="s1">&#39;alibaba&#39;</span><span class="p">,</span> <span class="n">organization</span><span class="o">=</span><span class="s1">&#39;40 Thieves&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This will print the key and title of all documents which have an <code class="docutils literal notranslate"><span class="pre">author</span></code> key
with value <code class="docutils literal notranslate"><span class="pre">'alibaba'</span></code> and an <code class="docutils literal notranslate"><span class="pre">organization</span></code> key with value <code class="docutils literal notranslate"><span class="pre">'40</span> <span class="pre">Thieves'</span></code>.
The current API only permits querying for exact matches and matching all of the
query terms.  More complex queries would need to be performed on an ad-hoc basis
on top of this API.</p>
<p>If all the user is concerned with is which keys match, there is an alternative
method <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.query_keys" title="encore.storage.abstract_store.AbstractReadOnlyStore.query_keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query_keys()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">query_keys</span><span class="p">(</span><span class="n">author</span><span class="o">=</span><span class="s1">&#39;alibaba&#39;</span><span class="p">,</span> <span class="n">organization</span><span class="o">=</span><span class="s1">&#39;40 Thieves&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>To iterate over all the keys in a store, you can simply call <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.query_keys" title="encore.storage.abstract_store.AbstractReadOnlyStore.query_keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query_keys()</span></code></a>
with no arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">query_keys</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, as a useful utility, you can use glob-style matching on the keys using
the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.glob" title="encore.storage.abstract_store.AbstractReadOnlyStore.glob"><code class="xref py py-meth docutils literal notranslate"><span class="pre">glob()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.jpg&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="writing">
<h2>Writing<a class="headerlink" href="#writing" title="Permalink to this heading">¶</a></h2>
<p>Most, but not all, stores also allow you to write data to keys.  The basic method
is <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.set" title="encore.storage.abstract_store.AbstractStore.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> which is the inverse of <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get" title="encore.storage.abstract_store.AbstractReadOnlyStore.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>.  It expects a
file-like object with a <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> method that can do buffering, and a
dictionary of metadata as arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cStringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s2">&quot;Hello World&quot;</span><span class="p">)</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s2">&quot;Greeting&quot;</span><span class="p">,</span> <span class="s1">&#39;author&#39;</span><span class="p">:</span> <span class="s1">&#39;alibaba&#39;</span><span class="p">}</span>
<span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">))</span>
</pre></div>
</div>
<p>As with reading, there are methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.set_data" title="encore.storage.abstract_store.AbstractStore.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_data()</span></code></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.set_metadata" title="encore.storage.abstract_store.AbstractStore.set_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_metadata()</span></code></a>
that permit you to set just one of the two parts of the value, and there are
utility methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.from_bytes" title="encore.storage.abstract_store.AbstractStore.from_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_bytes()</span></code></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.from_file" title="encore.storage.abstract_store.AbstractStore.from_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_file()</span></code></a> that populate
the data of a key from either a byte string or a binary file.  The latter two
methods do not set any metadata: that must be done manually if needed.</p>
<p>If you want to add to the metadata without overwriting it, there is a convenience
method <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.update_metadata" title="encore.storage.abstract_store.AbstractStore.update_metadata"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_metadata()</span></code></a> method that will update the
metadata dictionary in mych the same way that the standard Python dictionary’s
<code class="docutils literal notranslate"><span class="pre">update</span></code> method works.</p>
<p>You can delete a key with the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.delete" title="encore.storage.abstract_store.AbstractStore.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">store</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="transactions">
<h2>Transactions<a class="headerlink" href="#transactions" title="Permalink to this heading">¶</a></h2>
<p>The key-value store API does not assume that the underlying storage mechanism
has a notion of transactions, but if it does then it can be supported by the
key-value store.  Transactions are handled by context managers and the with
statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">store</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="s1">&#39;Setting some values&#39;</span><span class="p">):</span>
    <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;key1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">metadata1</span><span class="p">))</span>
    <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;key2&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">metadata2</span><span class="p">))</span>
</pre></div>
</div>
<p>If any exception were to occur in the with statement, the context manager will
ensure that the transaction gets rolled back.  Otherwise the transaction will
be committed when the with statement finishes.</p>
<p>Transactions are re-entrant, so it is safe to do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_keypair</span><span class="p">(</span><span class="n">keypair</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">store</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="s1">&#39;Adding keypair&#39;</span><span class="p">):</span>
        <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">key1</span><span class="p">,</span> <span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">data1</span><span class="p">,</span> <span class="n">keypair</span><span class="o">.</span><span class="n">metadata1</span><span class="p">))</span>
        <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">key2</span><span class="p">,</span> <span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">data2</span><span class="p">,</span> <span class="n">keypair</span><span class="o">.</span><span class="n">metadata2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">add_many_keypairs</span><span class="p">(</span><span class="n">keypairs</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">store</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="s1">&#39;Adding many keypairs&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">keypair</span> <span class="ow">in</span> <span class="n">keypairs</span><span class="p">:</span>
            <span class="n">add_keypair</span><span class="p">(</span><span class="n">keypair</span><span class="p">)</span>
</pre></div>
</div>
<p>The transaction in the function is effectively ignored, with only the outermost
transaction applying.</p>
</section>
<section id="the-multi-methods">
<h2>The “Multi” Methods<a class="headerlink" href="#the-multi-methods" title="Permalink to this heading">¶</a></h2>
<p>For convenience there are a collection of methods prefixed by “multi”, such as
<a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.multiget" title="encore.storage.abstract_store.AbstractReadOnlyStore.multiget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">multiget()</span></code></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.multiset_data" title="encore.storage.abstract_store.AbstractStore.multiset_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">multiset_data()</span></code></a>,
which perform the specified operations on a collection of keys at once.  If
transactions are available, then these will be done as a single transaction.</p>
</section>
<section id="events">
<h2>Events<a class="headerlink" href="#events" title="Permalink to this heading">¶</a></h2>
<p>The various stores use the Encore event system, which is why the stores must
be supplied with a reference to an EventManager instance.  The events which are
emitted are referenced in the documentation for each method.</p>
</section>
</section>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/img/e-logo.png" alt="Logo">
            </a></p>
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Usage</a><ul>
<li><a class="reference internal" href="#creating-and-connecting">Creating and Connecting</a></li>
<li><a class="reference internal" href="#reading">Reading</a></li>
<li><a class="reference internal" href="#querying">Querying</a></li>
<li><a class="reference internal" href="#writing">Writing</a></li>
<li><a class="reference internal" href="#transactions">Transactions</a></li>
<li><a class="reference internal" href="#the-multi-methods">The “Multi” Methods</a></li>
<li><a class="reference internal" href="#events">Events</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="concepts.html"
                          title="previous chapter">Key-Value Store Concepts</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="abstract_store.html"
                          title="next chapter">Key-Value Store API</a></p>
  </div>
  <h3>This Page</h3>
  <div>
    <a href="../_sources/storage/usage.rst.txt"
       rel="nofollow">Show Source</a>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2011-2022, Enthought, Inc.
      </li>
      <li>
      Last updated on Aug 19, 2022.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 5.1.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>